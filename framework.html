<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style type="text/css">body {padding: var(--universal-padding);} </style>
</head>
<body>

<h1>Form</h1>

<form>
  <label>Age</label><input data-wa-target="age" type="number" value="17">
  <div data-wa-style.display="target('age').depend('value') >= 18 ? 'block' : 'none'">You are an adult</div>
</form>

<h1>Table</h1>
<table>
  <thead>
    <tr><th>#</th><th>Test</th></tr>
  </thead>
  <tbody>
    <tr><td data-wa-innerhtml="target(this).depend('rowIndex') + 1"></td><td>Some Data</td></tr>
    <tr><td data-wa-innerhtml="target(this).depend('rowIndex') + 1"></td><td>Other Information</td></tr>
  </tbody>
</table>

<button onclick="addNewRow()" class="primary">Add a new row</button>

<script type="text/javascript">
  // ignore this test code
  function addNewRow() {
    const tbody = document.querySelector('tbody');
    const newTr = document.createElement('tr');
    const newTd1 = document.createElement('td');
    newTd1.setAttribute('data-wa-innerhtml', 'target(this).depend("rowIndex") + 1');
    const newTd2 = document.createElement('td');
    newTd2.innerHTML = Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);

    newTr.appendChild(newTd1);
    newTr.appendChild(newTd2);
    tbody.appendChild(newTr);
  }
  // end ignore

  // docker run -ti --rm -v $PWD:/app -w /app ruby /bin/bash
  // gem install haml
  // 

  /*
  1. check if currentUpdateHandler really must be like this
  2. refactor to allow generic case
      - <div data-mo="this.style.display = target('age').depend('value') > 18 ? 'block' : 'none'">You are an adult</div>
      - <div data-wa-depend="target('my-tbody').depend('mutation')" data-wa-run="sortTable()">
  */


  // TODO use proxy to wrap the element we depend on (when using @age.value, we wrap the age field with proxy)
  // TODO document

  // nomenclature:
  //   :binding
  //   target
  //   {{dependency}}
  // TODO add @click for listeners

  // &target - for a single target
  // later: &&target - for a list of targets

  // Polyfill potential: closest, Proxy

  // document: the framework
  // document: and I think it will be great for doing HTML over the wire and not having to use heavy stuff like react or vue in the frontend
  // document: this is declarative (the : indicates a dynamic expression). it is reactive ( {{ }} indicate that there is a dependency which needs to be monitored) and concise (& indicate targets for simple identification).
  // document: enhancing (also this)
  // document: global mutation observer

  let trackDependencies = false; // when depend is called, usually we do not add watchers for the attribute. If this is true, we do add watchers for depend() calls.
  let currentUpdateHandler; // TODO: is this really necessary?

  function enableDependencyTracking() { trackDependencies = true; }
  function disableDepencencyTracking() { trackDependencies = false; }

  // OUTDATED: utility function to access the target map (used by evaluateExpression)
  // OUTDATED: enhancing adds convenience values/functions such as rowIndex and such to the element.
  // OUTDATED: I would have loved to use Proxies for this, but: "Note that while this "no-op" works for JavaScript objects, it does not work for native browser objects like DOM Elements." (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
  function target(elementOrTargetName) {
    let target;
    if (typeof elementOrTargetName === 'object') { target = elementOrTargetName; }
    if (typeof elementOrTargetName === 'string') { target = document.querySelector(`[data-wa-target=${elementOrTargetName}]`); }

    if (!target) { throw `Could not find target for ${elementOrTargetName}`; }

    return enhanceElement(target); // wrap the target into a proxy here, so we can add methods such as rowIndex
  }

  function enhanceElement(element) {
    if (element._enhanced) { return element; }
    
    element.depend = (attrName) => {
      if (trackDependencies) {
        addListenerForDependency(element, attrName, currentUpdateHandler)
      }
      return element[attrName];
    }

    Object.defineProperty(element, 'rowIndex', {
      get: function() { 
        const parentRow = element.closest('tr');
        const parentTBody = parentRow.closest('tbody');
        const allRows = [...parentTBody.children];
        return allRows.indexOf(parentRow);
      }
    });
    // TODO (see document) add convenience methods different depending on their type (e.g. input vs. select vs. checkbox vs. radio)
    element._enhanced = true;
    return element;
  }

  // adds the watcher for dependencies and updates the binding for the first time
  function processBindingsForElement(element) {
    for (const attr of element.attributes) {
      // TODO this will have to change to allow the more generic use case
      if (attr.name.startsWith('data-wa')) {
        const targetAttr = attr.name.slice(8); // only the part after data-wa
        const expression = attr.value;
        
        if (targetAttr == 'target') { continue; } // ignore data-wa-target

        updateBinding(element, targetAttr, expression);
      }
    }
  }

  function addListenerForDependency(element, attribute, handler) {
    if (attribute == 'value') {
      // TODO handle inputs different depending on their type (e.g. input vs. select vs. checkbox vs. radio)
      element.addEventListener('change', handler)
      return;
    }
    if (attribute == 'rowIndex') {
      const observer = new MutationObserver(handler);
      observer.observe(element.closest('tbody'), { childList: true });
      return;
    }
    // TODO add more listeners for attributes
    throw `unsupported attribute ${attribute}, don't know how to observe changes for it`
  }

  // e.g. setValueForAttributePath(someElm, 'style.display', 'none')
  function setValueForAttributePath(element, attributePath, value) { // unfortunately we can not use Proxy for this (e.g. error: TypeError: 'get style' called on an object that does not implement interface HTMLElement.)
    attributePath = attributePath.toLowerCase();
    if (attributePath == 'innerhtml') {
      element.innerHTML = value;
      return;
    }
    // we set a regular attribute, we first need to find the right attribute (e.g. 'style.display' will yield the attribute `element['style']['display']`)
    const splitPath = attributePath.split('.');
    let attribute = element; // descend down the second last attribute
    for (const attrName of splitPath.slice(0, -1)) {
      attribute = attribute[attrName];
    }
    attribute[splitPath[splitPath.length-1]] = value;
  }

  // evaluates the expression and sets the result to the element's attribute (given by attributePath).
  function updateBinding(element, targetAttr, expression) {
    currentUpdateHandler = () => updateBinding(element, targetAttr, expression)
    const value = evaluateExpression(expression, element);
    setValueForAttributePath(element, targetAttr, value)
  }

  function evaluateExpression(expression, elementToPassAsThis) {
    let code = `return ${expression}`;
    try {
      return Function(code).apply(elementToPassAsThis);
    } catch (err) {
      throw `${err}\nin generated expression:\n${code}`;
    }
  }

  // add all (sub-)elements with targets set to the "targets" map and process the bindings.
  // this function recurses
  function setup(container) {
    enableDependencyTracking();
    processBindingsForElement(container);
    for (const child of container.children) { // recurse into children
      setup(child);
    }
    disableDepencencyTracking();
  }

  // sets up the evaluation of all bindings (and adding the necessary dependencies for them) for all elements children of the container
  setup(document.body);
  // setup a global mutation observer to call discover on it when new nodes come in (we do not monitor attributes here, this is done via the dependencies)
  const observer = new MutationObserver((mutationsList, _observer) => {
    for(const mutation of mutationsList) {
      for (const addedNode of mutation.addedNodes) {
        if (addedNode.nodeType == Node.ELEMENT_NODE) { // we ignore text & attributes
          setup(addedNode);
        }
      }
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
</script>

</div>
</body>
</html>